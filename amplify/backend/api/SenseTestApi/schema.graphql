type Project @model(queries: null, mutations: null) {
  id: ID!
  name: String!
  posts: [Post] @connection(keyName: "byProject", fields: ["id"])
}
type Post @model(queries: {list: "listPosts"})  
  @key(name: "byProject", fields:["projectId", "title"]) 
  {
  id: ID!
  title: String!
  imageId: ID!
  projectId: ID!
  text: String!
  createdAt: String
  updatedAt: String
  comments: [Comment] @connection(name: "PostComments")
}
type Comment @model(queries: {list: "listComments", get: "getComment"}) {
  id: ID!
  content: String
  post: Post @connection(name: "PostComments")
}

type Query {
  getPost(id: ID!): Post
  getProject(id: ID!): Project
  listProjects(filter: ModelProjectFilterInput, limit: Int, nextToken: String): ModelProjectConnection
}

type Mutation {
  createProject(input: CreateProjectInput!, condition: ModelProjectConditionInput): Project
}

## Project
type ModelProjectConnection {
	items: [Project]
	nextToken: String
}

input ModelProjectFilterInput {
	id: ModelIDInput
	name: ModelStringInput
	and: [ModelProjectFilterInput]
	or: [ModelProjectFilterInput]
	not: ModelProjectFilterInput
}

input ModelProjectConditionInput {
	name: ModelStringInput
	and: [ModelProjectConditionInput]
	or: [ModelProjectConditionInput]
	not: ModelProjectConditionInput
}
input CreateProjectInput {
	id: ID
	name: String!
}

## Generic
enum ModelAttributeTypes {
	binary
	binarySet
	bool
	list
	map
	number
	numberSet
	string
	stringSet
	_null
}
input ModelIDInput {
	ne: ID
	eq: ID
	le: ID
	lt: ID
	ge: ID
	gt: ID
	contains: ID
	notContains: ID
	between: [ID]
	beginsWith: ID
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
	size: ModelSizeInput
}
input ModelSizeInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
}
input ModelStringInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	contains: String
	notContains: String
	between: [String]
	beginsWith: String
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
	size: ModelSizeInput
}
